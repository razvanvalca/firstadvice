<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Voice Agent - ElevenLabs</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: linear-gradient(
          135deg,
          #1a1a2e 0%,
          #16213e 50%,
          #0f3460 100%
        );
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: white;
        padding: 20px;
      }

      .container {
        text-align: center;
        max-width: 600px;
        width: 100%;
      }

      h1 {
        font-size: 2.5rem;
        margin-bottom: 10px;
        background: linear-gradient(90deg, #00d4ff, #7c3aed);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .subtitle {
        color: #888;
        margin-bottom: 40px;
        font-size: 1.1rem;
      }

      .agent-container {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 20px;
        padding: 40px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        margin-bottom: 30px;
      }

      #call-button {
        width: 120px;
        height: 120px;
        border-radius: 50%;
        border: none;
        background: linear-gradient(135deg, #00d4ff, #7c3aed);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 20px;
        transition: all 0.3s ease;
        box-shadow: 0 10px 40px rgba(0, 212, 255, 0.3);
      }

      #call-button:hover {
        transform: scale(1.05);
        box-shadow: 0 15px 50px rgba(0, 212, 255, 0.4);
      }

      #call-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      #call-button.active {
        background: linear-gradient(135deg, #ef4444, #dc2626);
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          box-shadow: 0 10px 40px rgba(239, 68, 68, 0.4);
        }
        50% {
          box-shadow: 0 15px 60px rgba(239, 68, 68, 0.6);
        }
      }

      #call-button svg {
        width: 50px;
        height: 50px;
        fill: white;
      }

      #status {
        font-size: 1.2rem;
        color: #00d4ff;
        margin-bottom: 20px;
        min-height: 30px;
      }

      #status.error {
        color: #ef4444;
      }

      .transcript-container {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 15px;
        padding: 20px;
        margin-top: 20px;
        max-height: 300px;
        overflow-y: auto;
        text-align: left;
      }

      .transcript-container h3 {
        color: #888;
        margin-bottom: 15px;
        font-size: 0.9rem;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .message {
        padding: 10px 15px;
        border-radius: 10px;
        margin-bottom: 10px;
        animation: fadeIn 0.3s ease;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .message.user {
        background: rgba(124, 58, 237, 0.3);
        margin-left: 20%;
      }

      .message.agent {
        background: rgba(0, 212, 255, 0.2);
        margin-right: 20%;
      }

      .message .role {
        font-size: 0.75rem;
        color: #888;
        margin-bottom: 5px;
        text-transform: uppercase;
      }

      .footer {
        margin-top: 30px;
        color: #666;
        font-size: 0.9rem;
      }

      .footer a {
        color: #00d4ff;
        text-decoration: none;
      }

      /* Audio visualizer */
      .visualizer {
        display: flex;
        justify-content: center;
        align-items: flex-end;
        height: 40px;
        gap: 4px;
        margin: 20px 0;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .visualizer.active {
        opacity: 1;
      }

      .visualizer .bar {
        width: 6px;
        background: linear-gradient(to top, #00d4ff, #7c3aed);
        border-radius: 3px;
        animation: none;
      }

      .visualizer.active .bar {
        animation: visualize 0.5s ease-in-out infinite;
      }

      .visualizer .bar:nth-child(1) {
        animation-delay: 0s;
        height: 10px;
      }
      .visualizer .bar:nth-child(2) {
        animation-delay: 0.1s;
        height: 20px;
      }
      .visualizer .bar:nth-child(3) {
        animation-delay: 0.2s;
        height: 30px;
      }
      .visualizer .bar:nth-child(4) {
        animation-delay: 0.3s;
        height: 20px;
      }
      .visualizer .bar:nth-child(5) {
        animation-delay: 0.4s;
        height: 10px;
      }

      @keyframes visualize {
        0%,
        100% {
          transform: scaleY(1);
        }
        50% {
          transform: scaleY(1.8);
        }
      }

      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üéôÔ∏è Voice Agent</h1>
      <p class="subtitle">Powered by ElevenLabs Conversational AI</p>

      <div class="agent-container">
        <button id="call-button" disabled>
          <!-- Microphone icon -->
          <svg id="mic-icon" viewBox="0 0 24 24">
            <path
              d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm-1-9c0-.55.45-1 1-1s1 .45 1 1v6c0 .55-.45 1-1 1s-1-.45-1-1V5zm6 6c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"
            />
          </svg>
          <!-- Phone hang up icon (hidden by default) -->
          <svg id="hangup-icon" class="hidden" viewBox="0 0 24 24">
            <path
              d="M12 9c-1.6 0-3.15.25-4.6.72v3.1c0 .39-.23.74-.56.9-.98.49-1.87 1.12-2.66 1.85-.18.18-.43.28-.7.28-.28 0-.53-.11-.71-.29L.29 13.08c-.18-.17-.29-.42-.29-.7 0-.28.11-.53.29-.71C3.34 8.78 7.46 7 12 7s8.66 1.78 11.71 4.67c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-2.48 2.48c-.18.18-.43.29-.71.29-.27 0-.52-.11-.7-.28-.79-.74-1.69-1.36-2.67-1.85-.33-.16-.56-.5-.56-.9v-3.1C15.15 9.25 13.6 9 12 9z"
            />
          </svg>
        </button>

        <div id="status">Initializing...</div>

        <div class="visualizer" id="visualizer">
          <div class="bar"></div>
          <div class="bar"></div>
          <div class="bar"></div>
          <div class="bar"></div>
          <div class="bar"></div>
        </div>

        <div class="transcript-container" id="transcript-container">
          <h3>Conversation</h3>
          <div id="transcript"></div>
        </div>
      </div>

      <p class="footer">
        Built with
        <a href="https://elevenlabs.io/conversational-ai" target="_blank"
          >ElevenLabs Conversational AI</a
        >
      </p>
    </div>

    <script>
      // ElevenLabs Conversational AI Client
      class VoiceAgent {
        constructor(agentId) {
          this.agentId = agentId;
          this.ws = null;
          this.audioContext = null;
          this.mediaStream = null;
          this.audioWorklet = null;
          this.isConnected = false;
          this.isRecording = false;

          // Audio playback queue
          this.audioQueue = [];
          this.isPlaying = false;
          this.currentSource = null;

          // Callbacks
          this.onStatusChange = null;
          this.onTranscript = null;
          this.onAgentResponse = null;
          this.onError = null;
        }

        async start() {
          try {
            // Request microphone access
            this.mediaStream = await navigator.mediaDevices.getUserMedia({
              audio: {
                sampleRate: 16000,
                channelCount: 1,
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
              },
            });

            // Create audio context
            this.audioContext = new AudioContext({ sampleRate: 16000 });

            // Connect to ElevenLabs
            await this.connect();

            // Start capturing audio
            await this.startAudioCapture();
          } catch (error) {
            console.error("Failed to start:", error);
            if (this.onError) this.onError(error.message);
            throw error;
          }
        }

        async connect() {
          const url = `wss://api.elevenlabs.io/v1/convai/conversation?agent_id=${this.agentId}`;

          return new Promise((resolve, reject) => {
            this.ws = new WebSocket(url);

            this.ws.onopen = () => {
              console.log("WebSocket connected");
              this.isConnected = true;
              if (this.onStatusChange) this.onStatusChange("connected");
              resolve();
            };

            this.ws.onmessage = (event) => {
              this.handleMessage(JSON.parse(event.data));
            };

            this.ws.onerror = (error) => {
              console.error("WebSocket error:", error);
              if (this.onError) this.onError("Connection error");
              reject(error);
            };

            this.ws.onclose = () => {
              console.log("WebSocket closed");
              this.isConnected = false;
              if (this.onStatusChange) this.onStatusChange("disconnected");
            };
          });
        }

        handleMessage(data) {
          console.log("Message:", data.type, data);

          switch (data.type) {
            case "conversation_initiation_metadata":
              console.log(
                "Conversation started:",
                data.conversation_initiation_metadata_event?.conversation_id
              );
              if (this.onStatusChange) this.onStatusChange("ready");
              break;

            case "user_transcript":
              if (data.user_transcription_event?.user_transcript) {
                if (this.onTranscript) {
                  this.onTranscript(
                    data.user_transcription_event.user_transcript,
                    data.user_transcription_event.is_final
                  );
                }
              }
              break;

            case "agent_response":
              if (data.agent_response_event?.agent_response) {
                if (this.onAgentResponse) {
                  this.onAgentResponse(
                    data.agent_response_event.agent_response
                  );
                }
              }
              break;

            case "audio":
              if (data.audio_event?.audio_base_64) {
                this.playAudio(data.audio_event.audio_base_64);
              }
              break;

            case "interruption":
              this.stopAudioPlayback();
              break;

            case "ping":
              this.ws.send(JSON.stringify({ type: "pong" }));
              break;

            case "error":
              console.error("Agent error:", data.message);
              if (this.onError) this.onError(data.message || "Unknown error");
              break;
          }
        }

        async startAudioCapture() {
          const source = this.audioContext.createMediaStreamSource(
            this.mediaStream
          );

          // Create a script processor for audio capture
          // (AudioWorklet would be better but requires HTTPS)
          const bufferSize = 4096;
          const processor = this.audioContext.createScriptProcessor(
            bufferSize,
            1,
            1
          );

          processor.onaudioprocess = (e) => {
            if (!this.isConnected || !this.isRecording) return;

            const inputData = e.inputBuffer.getChannelData(0);

            // Convert Float32 to Int16
            const int16Data = new Int16Array(inputData.length);
            for (let i = 0; i < inputData.length; i++) {
              const s = Math.max(-1, Math.min(1, inputData[i]));
              int16Data[i] = s < 0 ? s * 0x8000 : s * 0x7fff;
            }

            // Send as base64
            const base64 = this.arrayBufferToBase64(int16Data.buffer);
            this.ws.send(
              JSON.stringify({
                user_audio_chunk: base64,
              })
            );
          };

          source.connect(processor);
          processor.connect(this.audioContext.destination);

          this.isRecording = true;
        }

        arrayBufferToBase64(buffer) {
          const bytes = new Uint8Array(buffer);
          let binary = "";
          for (let i = 0; i < bytes.byteLength; i++) {
            binary += String.fromCharCode(bytes[i]);
          }
          return btoa(binary);
        }

        base64ToArrayBuffer(base64) {
          const binary = atob(base64);
          const bytes = new Uint8Array(binary.length);
          for (let i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i);
          }
          return bytes.buffer;
        }

        async playAudio(base64Audio) {
          const arrayBuffer = this.base64ToArrayBuffer(base64Audio);

          // Convert Int16 to Float32
          const int16Data = new Int16Array(arrayBuffer);
          const float32Data = new Float32Array(int16Data.length);
          for (let i = 0; i < int16Data.length; i++) {
            float32Data[i] = int16Data[i] / 32768;
          }

          // Create audio buffer
          const audioBuffer = this.audioContext.createBuffer(
            1,
            float32Data.length,
            16000
          );
          audioBuffer.getChannelData(0).set(float32Data);

          // Queue the audio
          this.audioQueue.push(audioBuffer);
          this.processAudioQueue();
        }

        processAudioQueue() {
          if (this.isPlaying || this.audioQueue.length === 0) return;

          this.isPlaying = true;
          const audioBuffer = this.audioQueue.shift();

          const source = this.audioContext.createBufferSource();
          source.buffer = audioBuffer;
          source.connect(this.audioContext.destination);

          source.onended = () => {
            this.isPlaying = false;
            this.processAudioQueue();
          };

          this.currentSource = source;
          source.start();
        }

        stopAudioPlayback() {
          if (this.currentSource) {
            try {
              this.currentSource.stop();
            } catch (e) {}
            this.currentSource = null;
          }
          this.audioQueue = [];
          this.isPlaying = false;
        }

        stop() {
          this.isRecording = false;

          if (this.ws) {
            this.ws.close();
            this.ws = null;
          }

          if (this.mediaStream) {
            this.mediaStream.getTracks().forEach((track) => track.stop());
            this.mediaStream = null;
          }

          if (this.audioContext) {
            this.audioContext.close();
            this.audioContext = null;
          }

          this.stopAudioPlayback();
          this.isConnected = false;
        }
      }

      // UI Controller
      const callButton = document.getElementById("call-button");
      const micIcon = document.getElementById("mic-icon");
      const hangupIcon = document.getElementById("hangup-icon");
      const statusEl = document.getElementById("status");
      const visualizer = document.getElementById("visualizer");
      const transcriptEl = document.getElementById("transcript");

      let agent = null;
      let isInCall = false;

      // Fetch config and initialize
      async function init() {
        try {
          const response = await fetch("/api/config");
          const config = await response.json();

          if (!config.agent_id) {
            throw new Error("No agent ID configured");
          }

          agent = new VoiceAgent(config.agent_id);

          agent.onStatusChange = (status) => {
            switch (status) {
              case "connected":
                updateStatus("Connected, initializing...");
                break;
              case "ready":
                updateStatus("Listening... Speak now!");
                visualizer.classList.add("active");
                break;
              case "disconnected":
                updateStatus("Disconnected");
                endCall();
                break;
            }
          };

          agent.onTranscript = (text, isFinal) => {
            if (isFinal && text.trim()) {
              addMessage("user", text);
            }
          };

          agent.onAgentResponse = (text) => {
            addMessage("agent", text);
          };

          agent.onError = (error) => {
            updateStatus("Error: " + error, true);
          };

          updateStatus("Ready - Click to start");
          callButton.disabled = false;
        } catch (error) {
          console.error("Init error:", error);
          updateStatus("Failed to initialize: " + error.message, true);
        }
      }

      function updateStatus(text, isError = false) {
        statusEl.textContent = text;
        statusEl.className = isError ? "error" : "";
      }

      function addMessage(role, text) {
        const messageEl = document.createElement("div");
        messageEl.className = `message ${role}`;
        messageEl.innerHTML = `
                <div class="role">${role === "user" ? "You" : "Agent"}</div>
                <div class="text">${text}</div>
            `;
        transcriptEl.appendChild(messageEl);
        transcriptEl.parentElement.scrollTop =
          transcriptEl.parentElement.scrollHeight;
      }

      async function startCall() {
        if (isInCall) return;

        try {
          callButton.disabled = true;
          updateStatus("Starting call...");

          await agent.start();

          isInCall = true;
          callButton.classList.add("active");
          micIcon.classList.add("hidden");
          hangupIcon.classList.remove("hidden");
          callButton.disabled = false;
        } catch (error) {
          updateStatus("Failed to start: " + error.message, true);
          callButton.disabled = false;
        }
      }

      function endCall() {
        if (agent) {
          agent.stop();
        }

        isInCall = false;
        callButton.classList.remove("active");
        micIcon.classList.remove("hidden");
        hangupIcon.classList.add("hidden");
        visualizer.classList.remove("active");
        updateStatus("Call ended - Click to restart");
      }

      callButton.addEventListener("click", () => {
        if (isInCall) {
          endCall();
        } else {
          startCall();
        }
      });

      // Initialize on page load
      init();
    </script>
  </body>
</html>
