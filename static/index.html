<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Voice Agent - ElevenLabs Conversational AI</title>
    <style>
      :root {
        --primary: #667eea;
        --primary-dark: #5a67d8;
        --secondary: #f5576c;
        --bg-dark: #1a1a2e;
        --bg-darker: #16213e;
        --text: #ffffff;
        --text-muted: #a0aec0;
        --success: #48bb78;
        --warning: #ed8936;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, sans-serif;
        background: linear-gradient(
          135deg,
          var(--bg-dark) 0%,
          var(--bg-darker) 100%
        );
        color: var(--text);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .header {
        padding: 1.5rem 2rem;
        background: rgba(0, 0, 0, 0.2);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .logo {
        font-size: 1.5rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .connection-status {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.9rem;
        color: var(--text-muted);
      }

      .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: var(--warning);
      }

      .status-dot.connected {
        background: var(--success);
      }

      .main {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 2rem;
      }

      .agent-avatar {
        width: 180px;
        height: 180px;
        border-radius: 50%;
        background: linear-gradient(
          135deg,
          var(--primary) 0%,
          var(--secondary) 100%
        );
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 4rem;
        margin-bottom: 2rem;
        position: relative;
        box-shadow: 0 20px 60px rgba(102, 126, 234, 0.4);
        transition: all 0.3s ease;
      }

      .agent-avatar.speaking {
        animation: speaking-pulse 1s infinite;
      }

      .agent-avatar.listening {
        box-shadow: 0 20px 60px rgba(245, 87, 108, 0.4);
      }

      @keyframes speaking-pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      .audio-visualizer {
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        border: 3px solid transparent;
        transition: all 0.1s ease;
      }

      .audio-visualizer.active {
        border-color: rgba(255, 255, 255, 0.3);
        animation: visualizer-rotate 2s linear infinite;
      }

      @keyframes visualizer-rotate {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      .status-text {
        font-size: 1.2rem;
        color: var(--text-muted);
        margin-bottom: 2rem;
        min-height: 1.5rem;
      }

      .controls {
        display: flex;
        gap: 1rem;
        margin-bottom: 2rem;
      }

      .mic-button {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        border: none;
        background: linear-gradient(
          135deg,
          var(--primary) 0%,
          var(--primary-dark) 100%
        );
        color: white;
        font-size: 2rem;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
      }

      .mic-button:hover:not(:disabled) {
        transform: translateY(-3px);
        box-shadow: 0 15px 40px rgba(102, 126, 234, 0.5);
      }

      .mic-button:active:not(:disabled) {
        transform: translateY(0);
      }

      .mic-button.recording {
        background: linear-gradient(135deg, var(--secondary) 0%, #e53e3e 100%);
        animation: recording-pulse 1.5s infinite;
      }

      @keyframes recording-pulse {
        0%,
        100% {
          box-shadow: 0 0 0 0 rgba(245, 87, 108, 0.5);
        }
        50% {
          box-shadow: 0 0 0 20px rgba(245, 87, 108, 0);
        }
      }

      .mic-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .interrupt-button {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        border: 2px solid var(--text-muted);
        background: transparent;
        color: var(--text-muted);
        font-size: 1.2rem;
        cursor: pointer;
        transition: all 0.3s ease;
        align-self: center;
      }

      .interrupt-button:hover:not(:disabled) {
        border-color: var(--secondary);
        color: var(--secondary);
      }

      .interrupt-button:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .conversation {
        width: 100%;
        max-width: 600px;
        margin-top: 2rem;
      }

      .message {
        padding: 1rem 1.5rem;
        border-radius: 1rem;
        margin-bottom: 1rem;
        background: rgba(255, 255, 255, 0.05);
        position: relative;
      }

      .message.user {
        border-left: 4px solid var(--primary);
      }

      .message.agent {
        border-left: 4px solid var(--secondary);
      }

      .message-label {
        font-size: 0.75rem;
        color: var(--text-muted);
        margin-bottom: 0.5rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .message-text {
        font-size: 1rem;
        line-height: 1.5;
        min-height: 1.5rem;
      }

      .message-text.empty {
        color: var(--text-muted);
        font-style: italic;
      }

      .waveform {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 3px;
        height: 40px;
        margin: 1rem 0;
      }

      .waveform-bar {
        width: 4px;
        background: var(--primary);
        border-radius: 2px;
        height: 20px;
        transition: height 0.1s ease;
      }

      .footer {
        padding: 1rem 2rem;
        text-align: center;
        color: var(--text-muted);
        font-size: 0.8rem;
      }

      .footer a {
        color: var(--primary);
        text-decoration: none;
      }

      /* Responsive */
      @media (max-width: 600px) {
        .header {
          flex-direction: column;
          gap: 1rem;
          text-align: center;
        }

        .agent-avatar {
          width: 140px;
          height: 140px;
          font-size: 3rem;
        }

        .mic-button {
          width: 70px;
          height: 70px;
          font-size: 1.5rem;
        }
      }
    </style>
  </head>
  <body>
    <header class="header">
      <div class="logo">
        <span>ü§ñ</span>
        <span>Voice Agent</span>
      </div>
      <div class="connection-status">
        <div class="status-dot" id="statusDot"></div>
        <span id="connectionStatus">Connecting...</span>
      </div>
    </header>

    <main class="main">
      <div class="agent-avatar" id="agentAvatar">
        <div class="audio-visualizer" id="visualizer"></div>
        üéôÔ∏è
      </div>

      <div class="status-text" id="statusText">Initializing...</div>

      <div class="waveform" id="waveform">
        <div class="waveform-bar"></div>
        <div class="waveform-bar"></div>
        <div class="waveform-bar"></div>
        <div class="waveform-bar"></div>
        <div class="waveform-bar"></div>
        <div class="waveform-bar"></div>
        <div class="waveform-bar"></div>
        <div class="waveform-bar"></div>
      </div>

      <div class="controls">
        <button
          class="interrupt-button"
          id="interruptBtn"
          disabled
          title="Interrupt"
        >
          ‚èπÔ∏è
        </button>
        <button class="mic-button" id="micButton" disabled>üé§</button>
      </div>

      <div class="conversation">
        <div class="message user">
          <div class="message-label">You</div>
          <div class="message-text" id="userText">-</div>
        </div>
        <div class="message agent">
          <div class="message-label">Agent</div>
          <div class="message-text" id="agentText">-</div>
        </div>
      </div>
    </main>

    <footer class="footer">
      Powered by
      <a href="https://elevenlabs.io" target="_blank">ElevenLabs</a>
      Conversational AI
    </footer>

    <script>
      // Elements
      const statusDot = document.getElementById("statusDot");
      const connectionStatus = document.getElementById("connectionStatus");
      const agentAvatar = document.getElementById("agentAvatar");
      const visualizer = document.getElementById("visualizer");
      const statusText = document.getElementById("statusText");
      const waveform = document.getElementById("waveform");
      const waveformBars = document.querySelectorAll(".waveform-bar");
      const micButton = document.getElementById("micButton");
      const interruptBtn = document.getElementById("interruptBtn");
      const userText = document.getElementById("userText");
      const agentText = document.getElementById("agentText");

      // State
      let ws = null;
      let audioContext = null;
      let mediaStream = null;
      let processor = null;
      let isRecording = false;
      let isAgentSpeaking = false;
      let audioQueue = [];
      let isPlaying = false;
      let playbackContext = null;

      // Connect to WebSocket
      function connect() {
        const protocol = location.protocol === "https:" ? "wss:" : "ws:";
        ws = new WebSocket(`${protocol}//${location.host}/ws`);

        ws.onopen = () => {
          connectionStatus.textContent = "Connected";
          statusDot.classList.add("connected");
          statusText.textContent = "Connecting to agent...";
        };

        ws.onmessage = async (event) => {
          const data = JSON.parse(event.data);
          handleMessage(data);
        };

        ws.onclose = () => {
          connectionStatus.textContent = "Disconnected";
          statusDot.classList.remove("connected");
          micButton.disabled = true;
          interruptBtn.disabled = true;
          statusText.textContent = "Connection lost. Reconnecting...";

          // Reconnect after delay
          setTimeout(connect, 3000);
        };

        ws.onerror = (error) => {
          console.error("WebSocket error:", error);
          statusText.textContent = "Connection error";
        };
      }

      function handleMessage(data) {
        switch (data.type) {
          case "connected":
            micButton.disabled = false;
            statusText.textContent = "Ready - Click the microphone to speak";
            console.log("Connected to agent:", data.conversation_id);
            break;

          case "transcript":
            userText.textContent = data.text || "-";
            userText.classList.toggle("empty", !data.text);
            break;

          case "response":
            agentText.textContent = data.text || "-";
            agentText.classList.toggle("empty", !data.text);
            break;

          case "audio":
            const audioData = base64ToArrayBuffer(data.audio);
            queueAudio(audioData);
            break;

          case "agent_speaking":
            isAgentSpeaking = data.is_speaking;
            agentAvatar.classList.toggle("speaking", data.is_speaking);
            visualizer.classList.toggle("active", data.is_speaking);
            interruptBtn.disabled = !data.is_speaking;

            if (data.is_speaking) {
              statusText.textContent = "Agent is speaking...";
            } else {
              statusText.textContent = "Ready - Click the microphone to speak";
            }
            break;

          case "user_speaking":
            agentAvatar.classList.toggle("listening", data.is_speaking);
            if (data.is_speaking) {
              statusText.textContent = "Listening...";
            }
            break;

          case "error":
            console.error("Agent error:", data.message);
            statusText.textContent = "Error: " + data.message;
            break;
        }
      }

      // Microphone handling
      micButton.addEventListener("click", async () => {
        if (!isRecording) {
          await startRecording();
        } else {
          stopRecording();
        }
      });

      interruptBtn.addEventListener("click", () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "interrupt" }));
          stopPlayback();
        }
      });

      async function startRecording() {
        try {
          // Request microphone access
          mediaStream = await navigator.mediaDevices.getUserMedia({
            audio: {
              sampleRate: 16000,
              channelCount: 1,
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
            },
          });

          audioContext = new AudioContext({ sampleRate: 16000 });
          const source = audioContext.createMediaStreamSource(mediaStream);
          processor = audioContext.createScriptProcessor(4096, 1, 1);

          processor.onaudioprocess = (e) => {
            if (!isRecording) return;

            const input = e.inputBuffer.getChannelData(0);
            const pcm = floatTo16BitPCM(input);

            // Update waveform visualization
            updateWaveform(input);

            // Send audio to server
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(
                JSON.stringify({
                  type: "audio",
                  audio: arrayBufferToBase64(pcm),
                })
              );
            }
          };

          source.connect(processor);
          processor.connect(audioContext.destination);

          isRecording = true;
          micButton.classList.add("recording");
          micButton.textContent = "‚èπÔ∏è";
          statusText.textContent = "Listening... (click to stop)";
        } catch (error) {
          console.error("Microphone error:", error);
          statusText.textContent = "Microphone access denied";
        }
      }

      function stopRecording() {
        isRecording = false;

        if (processor) {
          processor.disconnect();
          processor = null;
        }

        if (mediaStream) {
          mediaStream.getTracks().forEach((track) => track.stop());
          mediaStream = null;
        }

        if (audioContext && audioContext.state !== "closed") {
          audioContext.close();
          audioContext = null;
        }

        micButton.classList.remove("recording");
        micButton.textContent = "üé§";
        statusText.textContent = "Processing...";

        // Reset waveform
        waveformBars.forEach((bar) => (bar.style.height = "20px"));

        // Signal end of turn
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "end_turn" }));
        }
      }

      // Audio playback
      function queueAudio(pcmData) {
        audioQueue.push(pcmData);
        if (!isPlaying) {
          processAudioQueue();
        }
      }

      async function processAudioQueue() {
        if (audioQueue.length === 0) {
          isPlaying = false;
          return;
        }

        isPlaying = true;
        const pcmData = audioQueue.shift();

        try {
          playbackContext = new AudioContext({ sampleRate: 16000 });
          const audioBuffer = playbackContext.createBuffer(
            1,
            pcmData.byteLength / 2,
            16000
          );
          const channelData = audioBuffer.getChannelData(0);
          const int16Array = new Int16Array(pcmData);

          for (let i = 0; i < int16Array.length; i++) {
            channelData[i] = int16Array[i] / 32768;
          }

          const source = playbackContext.createBufferSource();
          source.buffer = audioBuffer;
          source.connect(playbackContext.destination);

          source.onended = () => {
            if (playbackContext) {
              playbackContext.close().catch(() => {});
              playbackContext = null;
            }
            processAudioQueue();
          };

          source.start();
        } catch (error) {
          console.error("Playback error:", error);
          processAudioQueue();
        }
      }

      function stopPlayback() {
        audioQueue = [];
        isPlaying = false;
        if (playbackContext) {
          playbackContext.close().catch(() => {});
          playbackContext = null;
        }
      }

      // Utility functions
      function floatTo16BitPCM(float32Array) {
        const buffer = new ArrayBuffer(float32Array.length * 2);
        const view = new DataView(buffer);

        for (let i = 0; i < float32Array.length; i++) {
          const s = Math.max(-1, Math.min(1, float32Array[i]));
          view.setInt16(i * 2, s < 0 ? s * 0x8000 : s * 0x7fff, true);
        }

        return buffer;
      }

      function arrayBufferToBase64(buffer) {
        const bytes = new Uint8Array(buffer);
        let binary = "";
        for (let i = 0; i < bytes.byteLength; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
      }

      function base64ToArrayBuffer(base64) {
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
          bytes[i] = binary.charCodeAt(i);
        }
        return bytes.buffer;
      }

      function updateWaveform(audioData) {
        // Calculate RMS for visualization
        let sum = 0;
        for (let i = 0; i < audioData.length; i++) {
          sum += audioData[i] * audioData[i];
        }
        const rms = Math.sqrt(sum / audioData.length);
        const level = Math.min(1, rms * 10);

        waveformBars.forEach((bar, index) => {
          const variance = 0.3 + Math.random() * 0.7;
          const height = 10 + level * 40 * variance;
          bar.style.height = `${height}px`;
        });
      }

      // Initialize
      connect();

      // Cleanup on page unload
      window.addEventListener("beforeunload", () => {
        stopRecording();
        stopPlayback();
        if (ws) {
          ws.close();
        }
      });
    </script>
  </body>
</html>
